#ifndef TEXT_H
#define TEXT_H

#include <stddef.h>

char const * const asm_directives[] {
	"assume",
	"extern",
	"ident",
	"label",
	"private",
	"public",
	"weak",
	"section",
	"db",
	"dd",
	"dl",
	"dw",
	"rb",
};

enum class asm_enum_directives {
	ASSUME,
	EXTERN,
	IDENT,
	LABEL,
	PRIVATE,
	PUBLIC,
	WEAK,
	SECTION,
	DB,
	DD,
	DL,
	DW,
	RB,
};

char const * const unary_instructions[] {
	"NOP",
	"CCF",
	"SCF",
	"RLA",
	"RRA",
	"RLCA",
	"RRCA",
	"RLD",
	"RRD",
	"DAA",
	"CPL",
	"NEG",
	"EXX",
	"CPI",
	"CPIR",
	"CPD",
	"CPDR",
	"LDI",
	"LDIR",
	"LDD",
	"LDDR",
};

char const * const instruction_name_start[] {
	"adc",
	"adc.sis",
	"add",
	"add.sis",
	"and",
	"bit",
	"call",
	"ccf",
	"cp",
	"cpd",
	"cpdr",
	"cpi",
	"cpir",
	"cpl",
	"daa",
	"dec",
	"dec.sis",
	"di",
	"djnz",
	"ei",
	"ex",
	"ex.sis",
	"exx",
	"halt",
	"im",
	"in",
	"in0",
	"inc",
	"inc.sis",
	"ind",
	"ind2",
	"indm",
	"indmr",
	"indr",
	"indrx",
	"ini",
	"ini2",
	"ini2r",
	"inim",
	"inimr",
	"inir",
	"inirx",
	"jp",
	"jq",
	"jr",
	"ld",
	"ld.sis",
	"ldd",
	"lddr",
	"ldi",
	"ldir",
	"lea",
	"lea.sis",
	"mlt",
	"neg",
	"nop",
	"or",
	"otd2r",
	"otdm",
	"otdmr",
	"otir",
	"otirx",
	"out",
	"out0",
	"outd",
	"outd2",
	"outi",
	"outi2",
	"pea",
	"pop",
	"push",
	"res",
	"ret",
	"reti",
	"retn",
	"rl",
	"rla",
	"rlc",
	"rlca",
	"rld",
	"rr",
	"rra",
	"rrc",
	"rrca",
	"rrd",
	"rsmix",
	"rst",
	"sbc",
	"sbc.sis",
	"scf",
	"set",
	"sla",
	"sll",
	"slp",
	"sra",
	"srl",
	"stmix",
	"sub",
	"tst",
	"xor",
};

enum class instruction_enum_start {
	ADC,
	ADC_SIS,
	ADD,
	ADD_SIS,
	AND,
	BIT,
	CALL,
	CCF,
	CP,
	CPD,
	CPDR,
	CPI,
	CPIR,
	CPL,
	DAA,
	DEC,
	DEC_SIS,
	DI,
	DJNZ,
	EI,
	EX,
	EX_SIS,
	EXX,
	HALT,
	IM,
	IN,
	IN0,
	INC,
	INC_SIS,
	IND,
	IND2,
	INDM,
	INDMR,
	INDR,
	INDRX,
	INI,
	INI2,
	INI2R,
	INIM,
	INIMR,
	INIR,
	INIRX,
	JP,
	JQ,
	JR,
	LD,
	LD_SIS,
	LDD,
	LDDR,
	LDI,
	LDIR,
	LEA,
	LEA_SIS,
	MLT,
	NEG,
	NOP,
	OR,
	OTD2R,
	OTDM,
	OTDMR,
	OTIR,
	OTIRX,
	OUT,
	OUT0,
	OUTD,
	OUTD2,
	OUTI,
	OUTI2,
	PEA,
	POP,
	PUSH,
	RES,
	RET,
	RETI,
	RETN,
	RL,
	RLA,
	RLC,
	RLCA,
	RLD,
	RR,
	RRA,
	RRC,
	RRCA,
	RRD,
	RSMIX,
	RST,
	SBC,
	SBC_SIS,
	SCF,
	SET,
	SLA,
	SLL,
	SLP,
	SRA,
	SRL,
	STMIX,
	SUB,
	TST,
	XOR,
};

char const * const register_name[] {
	"a",
	"b",
	"c",
	"d",
	"e",
	"h",
	"l",
	"ixl",
	"ixh",
	"iyl",
	"iyh",
	"mb",
	"i",
	"r",
	"af",
	"bc",
	"de",
	"hl",
	"sp",
	"ix",
	"iy",
};

enum class ez80_argument_name {
	A,
	B,
	C,
	D,
	E,
	H,
	L,
	IXL,
	IXH,
	IYL,
	IYH,
	MB,
	I,
	R,
	AF,
	BC,
	DE,
	HL,
	SP,
	IX,
	IY,
	PHL,
	PDE,
	PBC,
	PIX,
	PIY,
	PSP,
};

char const * const argument_name[] {
	"a",
	"b",
	"c",
	"d",
	"e",
	"h",
	"l",
	"ixl",
	"ixh",
	"iyl",
	"iyh",
	"mb",
	"i",
	"r",
	"af",
	"bc",
	"de",
	"hl",
	"sp",
	"ix",
	"iy",
	"(hl)",
	"(de)",
	"(bc)",
	"(ix",
	"(iy",
	"(sp)",
};

enum class ez80_condition_code {
	C,
	NC,
	Z,
	NZ,
	P,
	M,
	PO,
	PE,
};

char const * const condition_code_name[] {
	"c",
	"nc",
	"z",
	"nz",
	"p",
	"m",
	"po",
	"pe",
};

#endif /* TEXT_H */
